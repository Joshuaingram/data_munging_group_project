# Server File for Flare Detection App V2
library(shiny)
library(latex2exp)
library(gridExtra)
library(tidyverse)
library(readr)
source("source_scripts/quality_metrics.R")

# load in airline data
flights <- read_csv("data/miami_flights_final.csv")
flights$seatsRemaining <- as.integer(flights$seatsRemaining)
flights$totalFare <- as.numeric(flights$totalFare)
flights$firstAirline <- as.factor(flights$firstAirline)
flights$layoverDurationInHours <- as.numeric(flights$layoverDurationInHours)
flights$arrivalHour <- as.integer(flights$arrivalHour)
flights$departureHour <- as.integer(flights$departureHour)
flights$destinationAirport <- as.factor(flights$destinationAirport)

server <- function(input, output, session){
  
  observeEvent(input$variable_metric, {
    print(input$variable_metric)
  })
  
  flights_metric <- reactive({
    
    data <- flights %>% 
      filter(firstAirline %in% input$airline_metric &
             destinationAirport %in% input$airport_metric) %>%
      select(!!!input$variable_metric)
    data
    
  })
  
  output$metric_table1 <- renderDataTable({
    data <- flights_metric()
    data
  })
  
  # graphs for probability-discounted power-law model
  output$fit_graphs1 <- renderPlot({
    
    # data to display and fit to
    data <- data_fit()
    
    # Defining input objects as variables
    min_data <- input$range_2[1]
    max_data <- input$range_2[2]
    H0 <- input$H0_2
    xi <- input$xi_2
    gamma <- input$gamma_2
    beta <- input$beta_2
    alpha <- input$alpha_2
    kappa <- input$kappa_2
    theta <- c(alpha, kappa, beta, gamma, xi)
    
    pi_fun <- function(x){
      # bounded sigmoid pi function
      f <- (H - H0)/(xi - H)
      pi <- (gamma * f^beta)/(1 + gamma * f^beta)
      pi[H <= H0] <- 0
      pi[H >= xi] <- 1
      pi[is.infinite(pi)] <- 1
    }
    
    lambda_fun <- function(x){
      (10^H0)^(alpha - 1)*(alpha - 1) * (10^H)^(-alpha) * log(10) * 10^H * 10^kappa
    }
    
    mu_fun <- function(x){
      pi <- pi_fun(x)
      lambda <- lambda_fun(x)
      mu <- lambda * pi
    }
    
    if (input$range_control == FALSE){
      
      df <- ggplot(data = data, aes(x=log(Gflrtotalenergy, 10))) + geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black")
      bins_data <- ggplot_build(df)$data[[1]]
      bins_data <- data.frame(y = bins_data$count, lb = bins_data$xmin, ub = bins_data$xmax, mids = bins_data$x)
      
      mu_vals <- apply(bins_data[,c(2,3)], 1, function(x) integral(fun = mu_bs, method = "Kron", xmin = x[1], xmax = x[2], theta = theta, H0 = H0))
      bins_data$mu_vals <- mu_vals / (bins_data[,"ub"] - bins_data[,"lb"])
      
      p1 <- ggplot(data = data, aes(x = log(Gflrtotalenergy, 10))) + 
        geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black") +
        geom_point(data = bins_data, aes(x = mids, y = mu_vals)) +
        xlim(input$range_2[1], input$range_2[2]) +
        theme_bw(base_size = 20) + 
        labs(x = "H", y = TeX("Observed Count and $\\mu_i$"), title = "Discrete Model Overlay") +
        geom_vline(xintercept = xi, color = "sienna2")
      
      if (input$residuals == FALSE){
        p2 <- ggplot(data = data, aes(x = log(Gflrtotalenergy, 10))) + 
          geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black") + 
          geom_function(fun = lambda_fun) +
          xlim(input$range_2[1], input$range_2[2]) +
          theme_bw(base_size = 20) + 
          labs(x = "H", y = TeX("Observed Count and $\\mu$"), title = "Continuous Model Overlay") +
          geom_vline(xintercept = xi, color = "sienna2")
        
        
        grid.arrange(p1, p2, ncol=2)
      } else {
        
        # calculuating residuals
        bins_data$residuals <- (bins_data[,"y"] - bins_data[,"mu_vals"])
        
        # residuals plot
        p3 <- ggplot(data = bins_data, aes(x = mids, y = residuals)) + 
          geom_point() + 
          geom_hline(yintercept = 0, linetype = "dotted") +
          xlim(input$range_2[1], input$range_2[2]) +
          theme_bw(base_size = 20) + 
          labs(x = "H", y = TeX("Observed Counts - $\\mu_i$"), title = "Residuals Plot") +
          geom_vline(xintercept = xi, color = "sienna2")
        
        grid.arrange(p1,p3, ncol=2)
        
      }
      
    } else{
      
      df <- ggplot(data = data, aes(x=log(Gflrtotalenergy, 10))) + geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black")
      bins_data <- ggplot_build(df)$data[[1]]
      bins_data <- data.frame(y = bins_data$count, lb = bins_data$xmin, ub = bins_data$xmax, mids = bins_data$x)
      
      mu_vals <- apply(bins_data[,c(2,3)], 1, function(x) integral(fun = mu_bs, method = "Kron", xmin = x[1], xmax = x[2], theta = theta, H0 = H0))
      bins_data$mu_vals <- mu_vals / (bins_data[,"ub"] - bins_data[,"lb"])
      
      p1 <- ggplot(data = data, aes(x = log(Gflrtotalenergy, 10))) + 
        geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black") +
        geom_point(data = bins_data, aes(x = mids, y = mu_vals)) +
        xlim(23, 32) +
        theme_bw(base_size = 20) + 
        labs(x = "H", y = TeX("Observed Count and $\\mu_i$"), title = "Discrete Model Overlay") +
        geom_vline(xintercept = xi, color = "sienna2")
      
      if (input$residuals == FALSE){
        p2 <- ggplot(data = data, aes(x = log(Gflrtotalenergy, 10))) + 
          geom_histogram(center = H0, binwidth = input$bins, fill = "aquamarine4", color = "black") + 
          geom_function(fun = lambda_fun) +
          xlim(23, 32) +
          theme_bw(base_size = 20) + 
          labs(x = "H", y = TeX("Observed Count and $\\mu$"), title = "Continuous Model Overlay") +
          geom_vline(xintercept = xi, color = "sienna2")
        
        
        grid.arrange(p1, p2, ncol=2)
      } else {
        
        # calculuating residuals
        bins_data$residuals <- (bins_data[,"y"] - bins_data[,"mu_vals"])
        
        # residuals plot
        p3 <- ggplot(data = bins_data, aes(x = mids, y = residuals)) + 
          geom_point() + 
          geom_hline(yintercept = 0, linetype = "dotted") +
          xlim(23, 32) +
          theme_bw(base_size = 20) + 
          labs(x = "H", y = TeX("Observed Counts - $\\mu_i$"), title = "Residuals Plot") +
          geom_vline(xintercept = xi, color = "sienna2")
        
        grid.arrange(p1,p3, ncol=2)
        
      }
      
    }
    
  })
  
  
  
  # graphs for probability-discounted power-law model
  output$model_graphs1 <- renderPlot({
    
    # Defining input objects as variables
    min_data <- input$range_1[1]
    max_data <- input$range_1[2]
    H0 <- input$H0_1
    xi <- input$xi_1
    gamma <- input$gamma_1
    beta <- input$beta_1
    alpha <- input$alpha_1
    kappa <- input$kappa_1
    
    pi_fun <- function(x){
      pi <- ifelse(x <= H0, 0, 
                   ifelse(x >= xi, 1, 
                          (gamma*((x - H0)/(xi - x))^beta)/(1 + gamma*((x - H0)/(xi - x))^beta)))
      pi[x <= H0] <- 0
      pi[x >= xi] <- 1
      pi[is.infinite(pi)] <- 1
      pi
      
    }
    
    f_fun <- function(x){
      ifelse(x == xi, NA, 
             (x - H0)/(xi - x))
    }
    
    lambda_fun <- function(x){
      (10^H0)^(alpha - 1)*(alpha - 1) * (10^x)^(-alpha) * log(10) * 10^x * 10^kappa
    }
    
    mu_fun <- function(x){
      pi <- pi_fun(x)
      lambda <- lambda_fun(x)
      mu <- lambda * pi
    }
    
    pi_plot <- ggplot() + 
      xlim(min_data, max_data) + 
      geom_function(fun = pi_fun, n = 1000) + 
      theme_bw(base_size = 20) + 
      labs(x = "H", y = TeX("$\\pi$")) +
      geom_vline(xintercept = xi, color = "sienna2")
    
    f_plot <- ggplot() + 
      xlim(min_data, max_data) + 
      geom_function(fun = f_fun, n = 700) + 
      theme_bw(base_size = 20) + 
      labs(x = "H", y = "f") +
      geom_vline(xintercept = xi, color = "sienna2")
    
    lambda_plot <- ggplot() + 
      xlim(min_data, max_data) + 
      geom_function(fun = lambda_fun, n = 1000) + 
      theme_bw(base_size = 20) + 
      labs(x = "H", y = TeX("$\\lambda$")) +
      geom_vline(xintercept = xi, color = "sienna2")
    
    mu_plot <- ggplot() + 
      xlim(min_data, max_data) + 
      geom_function(fun = mu_fun, n = 1000) + 
      theme_bw(base_size = 20) + 
      labs(x = "H", y = TeX("$\\mu$")) +
      geom_vline(xintercept = xi, color = "sienna2")
    
    grid.arrange(lambda_plot, pi_plot, mu_plot, f_plot, ncol = 2)
    
  })
  
}